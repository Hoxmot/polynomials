{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Poly",
				"PolyAdd"
			],
			[
				"Mon",
				"Mono"
			],
			[
				"pr",
				"printf\tprintf …"
			],
			[
				"poly",
				"polyPrint"
			],
			[
				"p",
				"printf\tprintf …"
			],
			[
				"mo",
				"monos"
			],
			[
				"Pol",
				"PolyDestroy"
			],
			[
				"e",
				"exp"
			],
			[
				"n",
				"next"
			],
			[
				"Mo",
				"MonoDestroy"
			],
			[
				"pol",
				"poly_coeff_t"
			],
			[
				"t",
				"true"
			],
			[
				"czy",
				"czyZero"
			],
			[
				"PolyI",
				"PolyIsZero"
			],
			[
				"ma",
				"malloc"
			],
			[
				"mono",
				"monos"
			],
			[
				"si",
				"sizeof"
			],
			[
				"c",
				"curr"
			],
			[
				"exe",
				"exercise2"
			],
			[
				"exer",
				"exercise1"
			],
			[
				"co",
				"correct"
			],
			[
				"this",
				"This"
			],
			[
				"no",
				"no"
			],
			[
				"histogram-",
				"histogram-marathoners-continue"
			],
			[
				"td",
				"td\tTag"
			],
			[
				"hit",
				"histograms"
			],
			[
				"i",
				"img\tTag"
			],
			[
				"squ",
				"square-root-choice"
			],
			[
				"m",
				"math"
			],
			[
				"text-a",
				"text-align"
			],
			[
				"wo",
				"word-break"
			],
			[
				"rea",
				"read-histogram"
			],
			[
				"o",
				"ol\tTag"
			],
			[
				"def",
				"definition"
			],
			[
				"an",
				"answer"
			],
			[
				"histo",
				"histograms"
			],
			[
				"fi",
				"fileName"
			],
			[
				"re",
				"removeFollowSign"
			],
			[
				"table",
				"tableName"
			],
			[
				"spl",
				"splitTableName"
			],
			[
				"l",
				"ls"
			],
			[
				"read",
				"readRow"
			],
			[
				"w",
				"write"
			],
			[
				"max",
				"max-width"
			],
			[
				"mi",
				"middle"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Wielomiany1/src/poly.c",
			"settings":
			{
				"buffer_size": 14513,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Wielomiany1/src/poly.h",
			"settings":
			{
				"buffer_size": 4710,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Wielomiany1/src/test_poly.c",
			"settings":
			{
				"buffer_size": 47810,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Wielomiany1/src/tmp_test.c",
			"settings":
			{
				"buffer_size": 1205,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Wielomiany1/TestKinds.param",
			"settings":
			{
				"buffer_size": 978,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "all                - run all tests"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/hoxmot/Documents/IPP/Wielomiany/IPP-kb392558",
		"/home/hoxmot/Documents/IPP/Wielomiany/IPP-kb392558/Wielomiany1",
		"/home/hoxmot/Documents/IPP/Wielomiany/IPP-kb392558/Wielomiany1/src",
		"/home/hoxmot/Documents/IPP/Wielomiany/IPP-kb392558/Wielomiany2",
		"/home/hoxmot/Documents/IPP/Wielomiany/IPP-kb392558/Wielomiany2/src"
	],
	"file_history":
	[
		"/home/hoxmot/Documents/Vertabelo/OldStuff/Stata/misc/template.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/descriptive-statistics/07-test.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/descriptive-statistics/02-histograms.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/descriptive-statistics/01-introduction.md",
		"/home/hoxmot/Documents/Vertabelo/tools/csv_to_html/mk_table.py",
		"/home/hoxmot/Documents/Vertabelo/OldStuff/Stata/misc/Marathoner.html",
		"/home/hoxmot/Documents/Vertabelo/OldStuff/Stata/misc/Internet_Websites.html",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/course.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/06-final-quiz.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/05-cte-data-modification.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/04-recursive-cte.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/03-nested-cte.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/02-syntax.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/01-intro-quiz.md",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/04-recursive-cte/data/Department.sql",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/04-recursive-cte/data/Employee.sql",
		"/home/hoxmot/Documents/Vertabelo/sql-academy-courses/common-table-expressions/01-intro-quiz/data/Part1.sql"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"define m",
			"MulTest",
			"MUL_SIMPLE",
			"eq",
			"ADDTest1",
			"des",
			"destr",
			"polyde",
			"decimal",
			"thief",
			"memo",
			"PolyDestroy",
			"MonoDestroy",
			"MemoryTh",
			"polyiszero",
			"addtest1",
			"add",
			"#include \"poly.h\"\n#include \"const_arr.h\"\n#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n#define ALL_TESTS \"all\"\n#define MEMORY \"memory\"\n#define LONG_POLYNOMIAL \"long-polynomial\"\n#define DEG \"deg\"\n#define DEG_SIMPLE \"deg-simple\"\n#define DEG_OP \"deg-op\"\n#define DEG_BY \"deg-by\"\n#define SIMPLE_AT \"simple-at\"\n#define SIMPLE_AT2 \"simple-at2\"\n#define AT \"at\"\n#define MUL_SIMPLE \"mul-simple\"\n#define MUL \"mul\"\n#define ADD \"add\"\n#define ADD_REQ \"add-req\"\n#define SUB \"sub\"\n#define SUB_REQ \"sub-req\"\n#define EQ \"eq\"\n#define EQ_SIMPLE \"eq-simple\"\n#define RARE \"rare\"\n#define MONO_ADD \"mono-add\"\n#define OVERFLOW \"overflow\"\n#define SIMPLE_ARITHMETIC \"simple-aritmethic\"\n#define SIMPLE_ARITHMETIC2 \"simple-aritmethic2\"\n\nbool SimpleArithmeticTest();\n\nbool LongPolynomialTest();\n\nbool DegreeOpChangeTest();\n\nbool SimpleAtTest2();\n\nbool AtTest();\n\nbool DegTest();\n\nbool DegByTest();\n\nbool MulTest();\n\nbool MulTest2();\n\nbool AddTest1();\n\nbool AddTest2();\n\nbool SubTest1();\n\nbool SubTest2();\n\nbool IsEqTest();\n\nbool RarePolynomialTest();\n\nbool SimpleAddTest();\n\nbool SimpleAddMonosTest();\n\nbool SimpleMulTest();\n\nbool SimpleNegTest();\n\nbool SimpleSubTest();\n\nbool SimpleDegByTest();\n\nbool SimpleDegTest();\n\nbool SimpleIsEqTest();\n\nbool SimpleAtTest();\n\nbool OverflowTest();\n\nvoid MemoryThiefTest();\n\nvoid MemoryTest();\n\nvoid PrintHelp(char *);\n\nint main(int argc, char **argv)\n{\n    if (argc != 2)\n    {\n        PrintHelp(argv[0]);\n        return -1;\n    }\n    if (strcmp(argv[1], MEMORY) == 0)\n    {\n        MemoryThiefTest();\n        MemoryTest();\n    }\n    else if (strcmp(argv[1], SIMPLE_ARITHMETIC) == 0)\n    {\n        bool res = true;\n        res &= SimpleAddTest();\n        res &= SimpleMulTest();\n        res &= SimpleNegTest();\n        res &= SimpleSubTest();\n        return !res;\n    }\n    else if (strcmp(argv[1], SIMPLE_ARITHMETIC2) == 0)\n    {\n        return !SimpleArithmeticTest();\n    }\n    else if (strcmp(argv[1], LONG_POLYNOMIAL) == 0)\n    {\n        return !LongPolynomialTest();\n    }\n    else if (strcmp(argv[1], DEG_OP) == 0)\n    {\n        return !DegreeOpChangeTest();\n    }\n    else if (strcmp(argv[1], DEG_SIMPLE) == 0)\n    {\n        bool res = true;\n        res &= SimpleDegTest();\n        res &= SimpleDegByTest();\n        return !res;\n    }\n    else if (strcmp(argv[1], DEG) == 0)\n    {\n        return !DegTest();\n    }\n    else if (strcmp(argv[1], DEG_BY) == 0)\n    {\n        return !DegByTest();\n    }\n    else if (strcmp(argv[1], SIMPLE_AT) == 0)\n    {\n        return !SimpleAtTest();\n    }\n    else if (strcmp(argv[1], SIMPLE_AT2) == 0)\n    {\n        return !SimpleAtTest2();\n    }\n    else if (strcmp(argv[1], AT) == 0)\n    {\n        return !AtTest();\n    }\n    else if (strcmp(argv[1], MUL_SIMPLE) == 0)\n    {\n        return !MulTest();\n    }\n    else if (strcmp(argv[1], MUL) == 0)\n    {\n        return !MulTest2();\n    }\n    else if (strcmp(argv[1], ADD) == 0)\n    {\n        return !AddTest1();\n    }\n    else if (strcmp(argv[1], ADD_REQ) == 0)\n    {\n        return !AddTest2();\n    }\n    else if (strcmp(argv[1], SUB) == 0)\n    {\n        return !SubTest1();\n    }\n    else if (strcmp(argv[1], SUB_REQ) == 0)\n    {\n        return !SubTest2();\n    }\n    else if (strcmp(argv[1], EQ_SIMPLE) == 0)\n    {\n        return !SimpleIsEqTest();\n    }\n    else if (strcmp(argv[1], EQ) == 0)\n    {\n        return !IsEqTest();\n    }\n    else if (strcmp(argv[1], RARE) == 0)\n    {\n        return !RarePolynomialTest();\n    }\n    else if (strcmp(argv[1], MONO_ADD) == 0)\n    {\n        return !SimpleAddMonosTest();\n    }\n    else if (strcmp(argv[1], OVERFLOW) == 0)\n    {\n        return !OverflowTest();\n    }\n    else if (strcmp(argv[1], ALL_TESTS) == 0)\n    {\n        int res = 0;\n        res += SimpleArithmeticTest();\n        res += LongPolynomialTest();\n        MemoryThiefTest();\n        MemoryTest();\n        res += DegreeOpChangeTest();\n        res += DegTest();\n        res += SimpleAtTest2();\n        res += AtTest();\n        res += MulTest();\n        res += MulTest2();\n        res += AddTest1();\n        res += AddTest2();\n        res += SubTest1();\n        res += SubTest2();\n        res += IsEqTest();\n        res += RarePolynomialTest();\n        res += SimpleAddMonosTest();\n        res += SimpleAddTest() &&\n                SimpleMulTest() &&\n                SimpleNegTest() &&\n                SimpleSubTest();//\n        res += SimpleDegByTest() && SimpleDegTest();\n        res += SimpleIsEqTest();\n        res += SimpleAtTest();//\n        res += OverflowTest();\n        printf(\"%d of 20 tests passed\\n\", res);\n    }\n    else\n    {\n        PrintHelp(argv[0]);\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * Wypisuje na standardowe wyjście informację o argumentach programu\n * @param program_name nazwa programu\n */\nvoid PrintHelp(char *program_name)\n{\n    const int width = 18;\n    printf(\"Usage: %s [target]\\nWhere target can be:\\n\", program_name);\n    printf(\"\\t%-*s - run all tests\\n\", width, ALL_TESTS);\n    printf(\"\\t%-*s - run memory test (run under valgrind)\\n\", width, MEMORY);\n    printf(\n        \"\\t%-*s - run test which constructing longer and longer polynomials\\n\",\n        width, LONG_POLYNOMIAL);\n    printf(\"\\t%-*s - run simple arithmetic test\\n\", width, SIMPLE_ARITHMETIC);\n    printf(\"\\t%-*s - run simple arithmetic test 2\\n\", width, SIMPLE_ARITHMETIC2);\n    printf(\"\\t%-*s - run simple deg test\\n\", width, DEG_SIMPLE);\n    printf(\"\\t%-*s - run deg test\\n\", width, DEG);\n    printf(\"\\t%-*s - run degBy test\\n\", width, DEG_BY);\n    printf(\"\\t%-*s - run deg chanege after operations test\\n\", width, DEG_OP);\n    printf(\"\\t%-*s - run simple at test\\n\", width, SIMPLE_AT);\n    printf(\"\\t%-*s - run simple at test 2\\n\", width, SIMPLE_AT);\n    printf(\"\\t%-*s - run at test\\n\", width, AT);\n    printf(\"\\t%-*s - run simple mul test\\n\", width, MUL_SIMPLE);\n    printf(\"\\t%-*s - run mul test\\n\", width, MUL);\n    printf(\"\\t%-*s - run add test\\n\", width, ADD);\n    printf(\"\\t%-*s - run recursion add test\\n\", width, ADD_REQ);\n    printf(\"\\t%-*s - run sub test\\n\", width, SUB);\n    printf(\"\\t%-*s - run recursion sub test\\n\", width, SUB_REQ);\n    printf(\"\\t%-*s - run equality test\\n\", width, EQ);\n    printf(\"\\t%-*s - run simple equality test\\n\", width, EQ_SIMPLE);\n    printf(\"\\t%-*s - run rare polynomial test\\n\", width, RARE);\n    printf(\"\\t%-*s - run overflow test\\n\", width, OVERFLOW);\n}\n\n/**\n * Testowanie czy operacja daje spodziewany wynik\n * @param a pierwszy wielomin\n * @param b drugi wielomian\n * @param res spodziewany wynik\n * @param op funkcja przyjmująca dwa wielomiany jako argument i zwracająca wielomian\n * (Domyślnie jedna z PolyAdd , PolySub, PolyMul)\n */\nbool TestOp(Poly *a, Poly *b, Poly res, Poly (*op)(const Poly *, const Poly *))\n{\n    Poly r = op(a, b);\n    bool compare_res = PolyIsEq(&r, &res);\n    PolyDestroy(&r);\n    PolyDestroy(&res);\n    return compare_res;\n}\n\n/**\n * Funkcja testująca dodawanie, odejmowanie i mnożenie liczb\n * za pomocą wielomianów\n */\nbool SimpleArithmeticTest()\n{\n\n    for (poly_coeff_t i = -100; i < 100; i++)\n    {\n        Poly p1 = PolyFromCoeff(i);\n        for (poly_coeff_t j = -100; j < 100; j++)\n        {\n            Poly p2 = PolyFromCoeff(j);\n            if (!TestOp(&p1, &p2, PolyFromCoeff(i + j), PolyAdd))\n            {\n                fprintf(stderr, \"Fail on adding %ld %ld\\n\", i, j);\n                return false;\n            }\n            if (!TestOp(&p1, &p2, PolyFromCoeff(i - j), PolySub))\n            {\n                fprintf(stderr, \"Fail on subbing %ld %ld\\n\", i, j);\n                return false;\n            }\n            if (!TestOp(&p1, &p2, PolyFromCoeff(i * j), PolyMul))\n            {\n                fprintf(stderr, \"Fail on multiply %ld %ld\\n\", i, j);\n                return false;\n            }\n            if (TestOp(&p1, &p2, PolyFromCoeff(i + j + 1), PolyAdd))\n            {\n                fprintf(stderr, \"Fail on adding %ld %ld\\n\", i, j);\n                return false;\n            }\n            if (TestOp(&p1, &p2, PolyFromCoeff(i - j - 1), PolySub))\n            {\n                fprintf(stderr, \"Fail on subbing %ld %ld\\n\", i, j);\n                return false;\n            }\n            if (TestOp(&p1, &p2, PolyFromCoeff(i * j + 1), PolyMul))\n            {\n                fprintf(stderr, \"Fail on multiply %ld %ld\\n\", i, j);\n                return false;\n            }\n            PolyDestroy(&p2);\n        }\n        PolyDestroy(&p1);\n    }\n    return true;\n}\n\n/**\n * Funkcja budująca coraz dłuższe wielomiany\n */\nbool LongPolynomialTest()\n{\n    bool res = true;\n    Poly p = PolyFromCoeff(1);\n    for (int poly_deg = 10; poly_deg < 90011 && res; poly_deg += 1000)\n    {\n        Mono *m =\n            calloc((size_t)poly_deg + 1, sizeof(Mono)); // +1 bo wyraz wolny\n        for (int i = 0; i <= poly_deg; i++)\n        {\n            Poly tmp = PolyClone(&p);\n            m[i] = MonoFromPoly(&tmp, i);\n        }\n        Poly long_p = PolyAddMonos((unsigned)poly_deg + 1, m);\n        // long_p ma postać 1 + x + x^2 + ...\n        free(m);\n        if (PolyDeg(&long_p) != poly_deg)\n        {\n            fprintf(stderr,\n                    \"[LongPolynomialTest] fail creating polynomial of deg %u\\n\",\n                    poly_deg);\n            res = false;\n        }\n        Poly mono_sum = PolyAt(&long_p, 1);\n        if (!PolyIsCoeff(&mono_sum))\n        {\n            fprintf(stderr, \"[LongPolynomialTest] fail on PolyAt [1]\\n\");\n            res = false;\n        }\n        Poly mono_sum_poly = PolyFromCoeff(poly_deg + 1);\n        if (!PolyIsEq(&mono_sum, &mono_sum_poly))\n        {\n            fprintf(stderr, \"[LongPolynomialTest] fail on PolyAt [2]\\n\");\n            res = false;\n        }\n        PolyDestroy(&mono_sum_poly);\n        PolyDestroy(&mono_sum);\n        mono_sum = PolyAt(&long_p, -1);\n        if (!PolyIsEq(&mono_sum, &p))\n        {\n            fprintf(stderr, \"[LongPolynomialTest] fail on PolyAt [3]\\n\");\n            res = false;\n        }\n        PolyDestroy(&mono_sum);\n        PolyDestroy(&long_p);\n    }\n\n    PolyDestroy(&p);\n    return res;\n}\n\n/**\n * Test czy funkcje PolyAddMonos i MonoFromPoly przejmują na własność\n * jednomiany i monomiany.\n * Uruchomione pod valgrindem nie powinno dawać wycieków pamięci\n */\nvoid MemoryThiefTest()\n{\n    const size_t poly_size = 10;\n    const int poly_depth = 3;\n    Poly p = PolyFromCoeff(1);\n    Mono *m = calloc(poly_size, sizeof(Mono));\n    for (int j = 0; j < poly_depth; j++)\n    {\n        for (int i = 0; i < (int)poly_size; i++)\n        {\n            Poly tmp = PolyClone(&p);\n            m[i] = MonoFromPoly(&tmp, i);\n        }\n        PolyDestroy(&p);\n        p = PolyAddMonos(poly_size, m);\n        // p = p + px + px^2\n    }\n    Poly p2 = PolyClone(&p);\n    Mono m2 = MonoFromPoly(&p2, 5);\n    MonoDestroy(&m2);\n    PolyDestroy(&p);\n    free(m);\n}\n\n/**\n * Sprawdza czy stopień wielomianu poprawnie się zmienia\n * przy wykonywaniu operacji arytmetycznych\n */\nbool DegreeOpChangeTest()\n{\n    Poly p_one = PolyFromCoeff(1);\n    Poly p_res = PolySub(&p_one, &p_one); // 1 - 1\n    if (!PolyIsZero(&p_res))\n    {\n        fprintf(stderr, \"[DegreeOpChangeTest] simple sub error\\n\");\n        return false;\n    }\n    PolyDestroy(&p_res);\n    Poly p2 = PolyNeg(&p_one);\n    p_res = PolyAdd(&p_one, &p2); // 1 + -1\n    if (!PolyIsZero(&p_res))\n    {\n        fprintf(stderr, \"[DegreeOpChangeTest] simple add error\\n\");\n        return false;\n    }\n    PolyDestroy(&p_res);\n    PolyDestroy(&p2);\n    {\n        const int poly_len = 5;\n        Mono m[poly_len];\n        for (int i = 0; i < poly_len; i++)\n        {\n            p2 = PolyClone(&p_one);\n            m[i] = MonoFromPoly(&p2, i);\n        }\n        Mono m2 = MonoClone(&m[poly_len - 1]);\n        p2 = PolyAddMonos(poly_len, m);\n        Poly p3 = PolyAddMonos(1, &m2);\n        p_res = PolySub(&p2, &p3); // (1 + x + ... + x^n) - x^n\n        if (PolyDeg(&p_res) != poly_len - 2)\n        {\n            fprintf(stderr, \"[DegreeOpChangeTest] one var poly sub error\\n\");\n            return false;\n        }\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n        PolyDestroy(&p_res);\n    }\n    {\n        const int poly_len = 5;\n        Mono m[poly_len];\n        for (int i = 0; i < poly_len - 1; i++)\n        {\n            p2 = PolyClone(&p_one);\n            m[i] = MonoFromPoly(&p2, i);\n        }\n        p2 = PolyClone(&p_one);\n        m[poly_len - 1] = MonoFromPoly(&p2, poly_len);\n        Mono m2[2];\n        m2[0] = MonoClone(&m[poly_len - 1]);\n\n        p2 = PolyAddMonos(poly_len, m);\n        Poly p3;\n        p3 = PolyClone(&p_one);\n        m2[1] = MonoFromPoly(&p3, poly_len - 1);\n\n        p3 = PolyAddMonos(2, m2);\n        p_res = PolySub(&p2, &p3);\n        // (1 + x + ... x^(n - 2) + x^n) - (x^(n-1) + x^n)\n        if (PolyDeg(&p_res) != poly_len - 1)\n        {\n            fprintf(stderr, \"[DegreeOpChangeTest] one var poly sub error\\n\");\n            return false;\n        }\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n        PolyDestroy(&p_res);\n    }\n    PolyDestroy(&p_one);\n    return true;\n}\n\n/**\n * Prosty test ewaluacji (PolyAt) wielomianów.\n * Testuje czy dobrze są dobrane typy danych.\n * Załada, że poly_coef_r jest typu long\n */\nbool SimpleAtTest2()\n{\n    Poly p_one = PolyFromCoeff(1);\n    Poly p_two = PolyFromCoeff(2);\n    Poly p, p_res, p_expected_res;\n    p_expected_res = PolyFromCoeff(LONG_MAX);\n    const int bits_num = sizeof(poly_coeff_t) * CHAR_BIT - 1;\n    Mono m[bits_num];\n    for (int i = 0; i < bits_num; i++)\n    {\n        p = PolyClone(&p_one);\n        m[i] = MonoFromPoly(&p, i);\n    }\n    p = PolyAddMonos((unsigned)bits_num, m);\n    p_res = PolyAt(&p, 2);\n    if (!PolyIsEq(&p_res, &p_expected_res))\n    {\n        fprintf(stderr, \"[SimpleAtTest2] error at first eval\\n\");\n        return false;\n    }\n    PolyDestroy(&p);\n    PolyDestroy(&p_res);\n    PolyDestroy(&p_expected_res);\n    p_expected_res = PolyFromCoeff(LONG_MAX - 1);\n    for (int i = 0; i < bits_num - 1; i++)\n    {\n        p = PolyClone(&p_two);\n        m[i] = MonoFromPoly(&p, i);\n    }\n    p = PolyAddMonos((unsigned)bits_num - 1, m);\n    p_res = PolyAt(&p, 2);\n    if (!PolyIsEq(&p_res, &p_expected_res))\n    {\n        fprintf(stderr, \"[SimpleAtTest2] error at second eval\\n\");\n        return false;\n    }\n    PolyDestroy(&p);\n    PolyDestroy(&p_res);\n    PolyDestroy(&p_expected_res);\n    PolyDestroy(&p_one);\n    PolyDestroy(&p_two);\n    return true;\n}\n/**\n * Buduje wielomian rekurencyjnie i sprawdza, czy\n * PolyAt tworzy odpowiedzni wielmian poly_depth zmiennych.\n *\n * Następnie testowane jest PolyDeg i PolyDegBy\n * czy działaja na prostym przypadku\n */\nbool AtTest()\n{\n    const size_t poly_size = 6;\n    const int poly_depth = 3;\n    const int upper_size = 5;\n    bool result = true;\n    Poly p = PolyFromCoeff(1);\n    Mono *m = calloc(poly_size, sizeof(Mono));\n    for (int j = 0; j < poly_depth; j++)\n    {\n        for (int i = 0; i < (int)poly_size; i++)\n        {\n            Poly tmp = PolyClone(&p);\n            m[i] = MonoFromPoly(&tmp, i);\n        }\n        PolyDestroy(&p);\n        p = PolyAddMonos(poly_size, m);\n        // p = p + px + ... + px^n\n\n    }\n    Poly p_upper_size = PolyFromCoeff(upper_size);\n    Poly p2 = PolyMul(&p_upper_size, &p);\n    free(m);\n    m = calloc(upper_size, sizeof(Mono));\n    for (int i = 0; i < upper_size; i++)\n    {\n        Poly tmp = PolyClone(&p);\n        m[i] = MonoFromPoly(&tmp, i);\n    }\n    PolyDestroy(&p);\n    p = PolyAddMonos(upper_size, m);\n    Poly p3 = PolyAt(&p, 1);\n    if (!PolyIsEq(&p3, &p2))\n    {\n        fprintf(stderr, \"[AtTest] fail\\n\");\n        result = false;\n    }\n    if (PolyDeg(&p) !=\n        (upper_size - 1) + (poly_depth * ((poly_exp_t)poly_size - 1)))\n    {\n        fprintf(stderr, \"[AtTest] PolyDeg fail\\n\");\n        result = false;\n    }\n    if (PolyDegBy(&p, 0) != upper_size - 1)\n    {\n        fprintf(stderr, \"[AtTest] PolyDegBy(..., 0) fail\\n\");\n        result = false;\n    }\n    if (PolyDegBy(&p, 1) != (poly_exp_t)poly_size - 1)\n    {\n        fprintf(stderr, \"[AtTest] PolyDegBy(..., 1) fail\\n\");\n        result = false;\n    }\n    PolyDestroy(&p);\n    PolyDestroy(&p2);\n    PolyDestroy(&p3);\n    PolyDestroy(&p_upper_size);\n    free(m);\n    return result;\n}\n\n/**\n * Tworzenie wielomianu jednej zmiennej z listy współczynników i wykładników\n * @param count rozmiar tablicy\n * @param val tablica współczynników\n * @param exp tablica wykładników\n */\nPoly MakePoly(unsigned count, const poly_coeff_t *val, poly_exp_t *exp)\n{\n    Mono *tmp = calloc(count, sizeof(struct Mono));\n    int shift = 0;\n    for (unsigned i = 0; i < count; i++)\n    {\n        Poly p = PolyFromCoeff(val[i]);\n        if (val[i] == 0)\n        {\n            shift--;\n            PolyDestroy(&p);\n        }\n        else\n        {\n            tmp[i + shift] = MonoFromPoly(&p, exp[i]);\n        }\n    }\n    Poly res = PolyAddMonos(count + shift, tmp);\n    free(tmp);\n    return res;\n}\n\n/**\n * Tworzenie wielomianu wielu zmiennych z listy wielomianów i wykładników\n * @param count rozmiar tablicy\n * @param val tablica współczynników\n * @param exp tablica wykładników\n */\nPoly MakePolyFromPolynomials(unsigned count, const Poly *val, poly_exp_t *exp)\n{\n    Mono *tmp = calloc(count, sizeof(struct Mono));\n    for (unsigned i = 0; i < count; i++)\n    {\n        tmp[i] = MonoFromPoly(&val[i], exp[i]);\n    }\n    Poly res = PolyAddMonos(count, tmp);\n    free(tmp);\n    return res;\n}\n\n/**\n * Buduje wielomian o określonej glebokości. Pobiera długość kolejnych\n * wielomianów z tablicy exp_arr i wykładniki z tablicy exp_arr1\n * współczynniki są z tablicy coef_arr1.\n * @param depth głębokość  (ilość zmiennych) wielomianu\n * @param exp_shift wkaźnik do zmiennej przechowywującej pozycje w\n * tablicach exp_arr i exp_arr2 (z const_arr.h)\n * @param coef_shift wkaźnik do zmiennej przechowywującej pozycje w\n * tablicy coef_arr1 (z const_arr.h)\n */\nPoly RecursiveBuild(int depth, int * exp_shift, int * coef_shift)\n{\n    if (depth == 0)\n        return PolyFromCoeff(coef_arr1[(*coef_shift)++]);\n    else\n    {\n        int size = exp_arr[*exp_shift];\n        *exp_shift += 1;\n        Mono m[size];\n        for (int i = 0; i < size; i++)\n        {\n            Poly p = RecursiveBuild(depth - 1, exp_shift, coef_shift);\n            if (PolyIsZero(&p))\n            {\n                PolyDestroy(&p);\n                Poly p2 = PolyFromCoeff(1);\n                m[i] = MonoFromPoly(&p2, exp_arr2[*exp_shift]);\n            }\n            else\n                m[i] = MonoFromPoly(&p, exp_arr2[*exp_shift]);\n            *exp_shift += 1;\n        }\n        return PolyAddMonos((unsigned) size, m);\n    }\n}\n\n/**\n * Buduje wielomian o określonej glebokości. Pobiera długość kolejnych\n * wielomianów z tablicy exp_arr i wykładniki z tablicy exp_arr (argument)\n * współczynniki są z tablicy coef_arr(argument).\n * @param depth głębokość (ilość zmiennych) wielomianu\n * @param exp_shift wkaźnik do zmiennej przechowywującej pozycje w\n * tablicy exp_arr\n * @param coef_shift coef_shift wkaźnik do zmiennej przechowywującej pozycje w\n * tablicy coef_arr\n * @param coef_arr tablica współczynników\n * @param exp_arr tablica wykładników i długości\n * @return\n */\nPoly RecursiveBuild2(int depth, int *exp_shift, int *coef_shift,\n                     const poly_coeff_t *coef_arr, const poly_exp_t *exp_arr)\n{\n    if (depth == 0)\n        return PolyFromCoeff(coef_arr[(*coef_shift)++]);\n    else\n    {\n        int size = exp_arr[*exp_shift];\n        *exp_shift += 1;\n        Mono m[size];\n        for (int i = 0; i < size; i++)\n        {\n            Poly p = RecursiveBuild2(depth - 1, exp_shift, coef_shift, coef_arr, exp_arr);\n            if (PolyIsZero(&p))\n            {\n                PolyDestroy(&p);\n                Poly p2 = PolyFromCoeff(1);\n                m[i] = MonoFromPoly(&p2, exp_arr[*exp_shift]);\n            }\n            else\n                m[i] = MonoFromPoly(&p, exp_arr[*exp_shift]);\n            *exp_shift += 1;\n        }\n        return PolyAddMonos((unsigned) size, m);\n    }\n}\n\n/**\n * Sprawdza czy PolyDegBy i PolyDeg przeglądają wszystkie potrzebne\n * elementy struktury\n */\nbool DegByTest()\n{\n    bool result = true;\n    int exp_shift = 0;\n    int coef_shift = 0;\n    const unsigned depth = 5;\n    Poly p = RecursiveBuild(depth, &exp_shift, &coef_shift);\n    int deg_arr[] = {355, 368, 384, 399, 399};\n    for (unsigned i=0; i < depth; i++)\n    {\n        if (deg_arr[i] !=  PolyDegBy(&p, i))\n        {\n            fprintf(stderr, \"[DegByTest] PolyDegBy(..., %d) fail\\n\", i);\n            result = false;\n        }\n    }\n    if (1639 != PolyDeg(&p))\n    {\n        fprintf(stderr, \"[DegByTest] PolyDeg fail\\n\");\n        result = false;\n    }\n    PolyDestroy(&p);\n\n    return result;\n}\n\n\n/**\n * Sprawdza mnożenie na wzorach skróconego mnożenia\n */\nbool MulTest()\n{\n    {\n        poly_coeff_t val[] = {1, 1};\n        poly_exp_t exp[] = {0, 1};\n        Poly p1 = MakePoly(2, val, exp);\n        Poly p2 = PolyMul(&p1, &p1);\n        poly_coeff_t res_val[] = {1, 2, 1};\n        poly_exp_t res_exp[] = {0, 1, 2};\n        Poly p_res1 = MakePoly(3, res_val, res_exp);\n        if (!PolyIsEq(&p2, &p_res1))\n        {\n            fprintf(stderr, \"[MulTest] PolyMul (1) error\\n\");\n            return false;\n        }\n        PolyDestroy(&p2);\n        PolyDestroy(&p_res1);\n        PolyDestroy(&p1);\n    }\n    {\n        poly_coeff_t val1[] = {1, 1};\n        poly_coeff_t val2[] = {1, -1};\n        poly_exp_t exp[] = {0, 1};\n        poly_exp_t exp_res[] = {0, 2};\n        Poly p1 = MakePoly(2, val1, exp);\n        Poly p2 = MakePoly(2, val2, exp);\n        Poly p3 = PolyMul(&p1, &p2);\n        Poly p_res1 = MakePoly(2, val2, exp_res);\n        if (!PolyIsEq(&p3, &p_res1))\n        {\n            fprintf(stderr, \"[MulTest] PolyMul (2) error\\n\");\n            return false;\n        }\n        PolyDestroy(&p3);\n        PolyDestroy(&p_res1);\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n    }\n    {\n        Poly p_two = PolyFromCoeff(2);\n        poly_coeff_t val[] = {1, 1};\n        poly_exp_t exp[] = {0, 1};\n        Poly p1 = MakePoly(2, val, exp);\n        Poly p_arr[] = {PolyClone(&p1), PolyClone(&p1)};\n        Poly p2 = MakePolyFromPolynomials(2, p_arr, exp);\n        Poly p3 = PolyMul(&p2, &p2);\n        poly_coeff_t res_val[] = {1, 2, 1};\n        poly_exp_t res_exp[] = {0, 1, 2};\n        Poly p_res1 = MakePoly(3, res_val, res_exp);\n        Poly p_arr2[] = {PolyClone(&p_res1), PolyMul(&p_res1, &p_two),\n                         PolyClone(&p_res1)};\n        Poly p_res2 = MakePolyFromPolynomials(3, p_arr2, res_exp);\n        if (!PolyIsEq(&p3, &p_res2))\n        {\n            fprintf(stderr, \"[MulTest] PolyMul (3) error\\n\");\n            return false;\n        }\n        PolyDestroy(&p_two);\n        PolyDestroy(&p3);\n        PolyDestroy(&p_res1);\n        PolyDestroy(&p_res2);\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n    }\n\n    return true;\n}\n\n/**\n * Buduje wielomian @p rec zmiennych,\n * gdzie każda zmienna występuje w dokładnie jednym jednomianie\n * @param coef_arr\n * @param exp_arr\n * @param rec\n */\nPoly BuildRecursivePoly(const poly_coeff_t * coef_arr, const poly_exp_t * exp_arr, size_t rec)\n{\n    Poly res = PolyZero();\n    for (size_t i = rec; i > 0 ; i--){\n        poly_coeff_t coef = coef_arr[i - 1];\n        poly_exp_t exp = exp_arr[i - 1];\n        if (coef == 0)\n        {\n            if (!PolyIsZero(&res))\n            {\n                Mono m = MonoFromPoly(&res, 0);\n                res = PolyAddMonos(1, &m);\n            }\n            continue;\n        }\n        Poly p = PolyFromCoeff(coef);\n        if (PolyIsZero(&res))\n        {\n            Mono m = MonoFromPoly(&p, exp);\n            PolyDestroy(&res);\n            res = PolyAddMonos(1, &m);\n        }\n        else\n        {\n            Mono m[2] = {MonoFromPoly(&p, exp), MonoFromPoly(&res, 0)};\n            res = PolyAddMonos(2, m);\n        }\n    }\n    return res;\n}\n\n/**\n * Testuje czy dodawanie długich wielomianów jednej zmiennej działa poprawnie\n * Testuje działanie PolyNeg\n */\nbool AddTest1()\n{\n    const poly_exp_t step = 10;\n    bool good = true;\n    size_t current_max_exp = 10;\n    size_t previous_current_max_exp = 0;\n    poly_exp_t *exp_list = calloc(conf_size, sizeof(poly_exp_t));\n    poly_coeff_t *poly_coef_res_arr = calloc(conf_size, sizeof(poly_coeff_t));\n    for (poly_exp_t i = 0; i < (poly_exp_t)conf_size; i++)\n    {\n        exp_list[i] = i;\n        poly_coef_res_arr[i] = coef_arr2[i];\n    }\n    while (current_max_exp <= conf_size && good)\n    {\n        for (size_t i = previous_current_max_exp; i < current_max_exp; i++)\n        {\n            poly_coef_res_arr[i] = coef_arr1[i] + coef_arr2[i];\n        }\n        previous_current_max_exp = current_max_exp;\n        Poly p1 = MakePoly((unsigned)current_max_exp, coef_arr1, exp_list);\n        size_t local_max_exp = current_max_exp;\n        while (local_max_exp <= conf_size && good)\n        {\n            Poly p2 = MakePoly((unsigned)local_max_exp, coef_arr2, exp_list);\n            Poly p3 = PolyAdd(&p1, &p2);\n            PolyDestroy(&p2);\n            Poly p_expected_res =\n                MakePoly((unsigned)local_max_exp, poly_coef_res_arr, exp_list);\n            if (!PolyIsEq(&p3, &p_expected_res))\n            {\n                fprintf(stderr, \"[AddTest1] error for %lu %lu\", current_max_exp,\n                        local_max_exp);\n                good = false;\n            }\n            PolyDestroy(&p3);\n            PolyDestroy(&p_expected_res);\n            local_max_exp *= step;\n        }\n        Poly p2 = PolyNeg(&p1);\n        Poly p3 = PolyAdd(&p2, &p1);\n        if (!PolyIsZero(&p3))\n        {\n            fprintf(stderr, \"[AddTest1] error for %lu in PolyNeg add\",\n                    current_max_exp);\n            good = false;\n        }\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n        current_max_exp *= step;\n    }\n    free(exp_list);\n    free(poly_coef_res_arr);\n    return good;\n}\n\n/**\n * Testuje czy dodawanie długich wielomianów wielu zmiennych działa poprawnie\n * Testuje działanie PolyNeg\n */\nbool AddTest2()\n{\n    bool good = true;\n    const poly_exp_t step = 2;\n    poly_coeff_t *pol_arr_expected_res = calloc(conf_size, sizeof(poly_coeff_t));\n    for (size_t j = 0; j < conf_size; ++j)\n    {\n        pol_arr_expected_res[j] = coef_arr2[j];\n    }\n\n    size_t prev_poly_len = 0;\n    size_t first_poly_len = 2;\n    size_t second_poly_len;\n    while (first_poly_len <= conf_size && good)\n    {\n        for (size_t i = prev_poly_len; i < first_poly_len; ++i)\n        {\n            pol_arr_expected_res[i] += coef_arr1[i];\n        }\n        prev_poly_len = first_poly_len;\n        Poly p1 = BuildRecursivePoly(coef_arr1, exp_arr, first_poly_len);\n        second_poly_len = first_poly_len;\n        while (second_poly_len <= conf_size && good)\n        {\n            Poly p2 = BuildRecursivePoly(coef_arr2, exp_arr, second_poly_len);\n            Poly p_res = PolyAdd(&p1, &p2);\n            PolyDestroy(&p2);\n            Poly p_expected_res = BuildRecursivePoly(pol_arr_expected_res, exp_arr, second_poly_len);\n            if (!PolyIsEq(&p_res, &p_expected_res))\n            {\n                fprintf(stderr, \"[AddTest2] error for %lu %lu\\n\",\n                        first_poly_len, second_poly_len);\n                good = false;\n            }\n            PolyDestroy(&p_res);\n            PolyDestroy(&p_expected_res);\n            second_poly_len *= step;\n        }\n        Poly p2 = PolyNeg(&p1);\n        Poly p3 = PolyAdd(&p2, &p1);\n        if (!PolyIsZero(&p3))\n        {\n            fprintf(stderr, \"[AddTest2] error for %lu in PolyNeg add\",\n                    first_poly_len);\n            good = false;\n        }\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n        first_poly_len *= step;\n    }\n    free(pol_arr_expected_res);\n\n    return good;\n}\n\n/**\n * Testuje czy odejmowanie długich wielomianów jednej zmiennej działa poprawnie\n */\nbool SubTest1()\n{\n    const poly_exp_t step = 10;\n    bool good = true;\n    size_t current_max_exp = 10;\n    size_t previous_current_max_exp = 0;\n    poly_exp_t *exp_list = calloc(conf_size, sizeof(poly_exp_t));\n    poly_coeff_t *poly_coef_res_arr = calloc(conf_size, sizeof(poly_coeff_t));\n    for (poly_exp_t i = 0; i < (poly_exp_t)conf_size; i++)\n    {\n        exp_list[i] = i;\n        poly_coef_res_arr[i] = coef_arr2[i];\n    }\n    while (current_max_exp <= conf_size && good)\n    {\n        for (size_t i = previous_current_max_exp; i < current_max_exp; i++)\n        {\n            poly_coef_res_arr[i] = coef_arr2[i] - coef_arr1[i];\n        }\n        previous_current_max_exp = current_max_exp;\n        Poly p1 = MakePoly((unsigned)current_max_exp, coef_arr1, exp_list);\n        size_t local_max_exp = current_max_exp;\n        while (local_max_exp <= conf_size && good)\n        {\n            Poly p2 = MakePoly((unsigned)local_max_exp, coef_arr2, exp_list);\n            Poly p3 = PolySub(&p2, &p1);\n            Poly p_expected_res =\n                MakePoly((unsigned)local_max_exp, poly_coef_res_arr, exp_list);\n            if (!PolyIsEq(&p3, &p_expected_res))\n            {\n                fprintf(stderr, \"[SubTest1] error for %lu %lu\", current_max_exp,\n                        local_max_exp);\n                good = false;\n            }\n            PolyDestroy(&p3);\n            PolyDestroy(&p2);\n            PolyDestroy(&p_expected_res);\n            local_max_exp *= step;\n        }\n        PolyDestroy(&p1);\n        current_max_exp *= step;\n    }\n    free(exp_list);\n    free(poly_coef_res_arr);\n    return good;\n}\n\n/**\n * Testuje czy odejmowanie długich wielomianów wielu zmiennych działa poprawnie\n */\nbool SubTest2()\n{\n    bool good = true;\n    const poly_exp_t step = 2;\n    poly_coeff_t *pol_arr_expected_res = calloc(conf_size, sizeof(poly_coeff_t));\n    for (size_t j = 0; j < conf_size; ++j)\n    {\n        pol_arr_expected_res[j] = coef_arr2[j];\n    }\n\n    size_t prev_poly_len = 0;\n    size_t first_poly_len = 2;\n    size_t second_poly_len;\n    while (first_poly_len <= conf_size && good)\n    {\n        for (size_t i = prev_poly_len; i < first_poly_len; ++i)\n        {\n            pol_arr_expected_res[i] -= coef_arr1[i];\n        }\n        prev_poly_len = first_poly_len;\n        Poly p1 = BuildRecursivePoly(coef_arr1, exp_arr, first_poly_len);\n        second_poly_len = first_poly_len;\n        while (second_poly_len <= conf_size && good)\n        {\n            Poly p2 = BuildRecursivePoly(coef_arr2, exp_arr, second_poly_len);\n            Poly p_res = PolySub(&p2, &p1);\n            Poly p_expected_res = BuildRecursivePoly(pol_arr_expected_res, exp_arr, second_poly_len);\n            if (!PolyIsEq(&p_res, &p_expected_res))\n            {\n                fprintf(stderr, \"[SubTest2] error for %lu %lu\\n\",\n                        first_poly_len, second_poly_len);\n                good = false;\n            }\n            PolyDestroy(&p2);\n            PolyDestroy(&p_res);\n            PolyDestroy(&p_expected_res);\n            second_poly_len *= step;\n        }\n        Poly p2 = PolyNeg(&p1);\n        Poly p3 = PolyAdd(&p2, &p1);\n        if (!PolyIsZero(&p3))\n        {\n            fprintf(stderr, \"[AddTest2] error for %lu in PolyNeg add\",\n                    first_poly_len);\n            good = false;\n        }\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n        first_poly_len *= step;\n    };\n    free(pol_arr_expected_res);\n\n    return good;\n}\n\n/**\n * Funkcja pomocnicza do tworzenie wyników mnożenia wielomianow \n * @param size1 długość danych w arr_1\n * @param arr_1 tablica wspolczynnikow pierwszego wielomiannu\n * @param size2 długość danych w arr_2\n * @param arr_2 tablica wspolczynnikow drugiego wielomiannu\n */\npoly_coeff_t *MullArray(size_t size1, const poly_coeff_t *arr_1, size_t size2,\n                        const poly_coeff_t *arr_2)\n{\n    poly_coeff_t *res = calloc(size1 + size2, sizeof(poly_coeff_t));\n    for (size_t i = 0; i < size1; i++)\n    {\n        for (size_t j = 0; j < size2; ++j)\n        {\n            res[i + j] += arr_1[i] * arr_2[j];\n        }\n    }\n    return res;\n}\n\n/**\n * Test mnożenia długich wielomianów.\n * Sprawdza poprawność i wydajność implementacji\n */\nbool MulTest2()\n{\n    bool good = true;\n    size_t step = 10;\n    size_t poly_one_len = 5;\n    size_t poly_two_len;\n    size_t current_conf_size = 501; // conf_size+1; - dla ambitnych: wzorcowe\n    // rozwiązanie w trybe relase na studentsie wykonuje się w 1m44.373s (real) \n    poly_exp_t *exp_list = calloc(2 * current_conf_size, sizeof(poly_exp_t));\n    for (poly_exp_t i = 0; i < (poly_exp_t)current_conf_size * 2; i++)\n    {\n        exp_list[i] = i;\n    }\n    while (poly_one_len < current_conf_size && good)\n    {\n        poly_two_len = poly_one_len;\n        Poly p1 = MakePoly((unsigned)poly_one_len, coef_arr1, exp_list);\n        while (poly_two_len < current_conf_size && good)\n        {\n            Poly p2 = MakePoly((unsigned)poly_two_len, coef_arr2, exp_list);\n            poly_coeff_t *expected_res_coef =\n                MullArray(poly_one_len, coef_arr1, poly_two_len, coef_arr2);\n            Poly p_expected_res =\n                MakePoly((unsigned)(poly_one_len + poly_two_len),\n                         expected_res_coef, exp_list);\n            Poly p_res = PolyMul(&p1, &p2);\n            if (!PolyIsEq(&p_expected_res, &p_res))\n            {\n                fprintf(stderr, \"[MulTest2] error for %lu %lu\\n\", poly_one_len,\n                        poly_two_len);\n                good = false;\n            }\n            PolyDestroy(&p2);\n            PolyDestroy(&p_expected_res);\n            PolyDestroy(&p_res);\n            free(expected_res_coef);\n            poly_two_len *= step;\n        }\n        PolyDestroy(&p1);\n        poly_one_len *= step;\n    }\n    free(exp_list);\n    return good;\n}\n\n/**\n * Sprawdza poprawność działania funkcji PolyIsEq na dłuższych przykładach\n * @return\n */\nbool IsEqTest()\n{\n    bool result = true;\n    const size_t copy_size = 1000;\n    poly_coeff_t *coef_copy = calloc(copy_size, sizeof(poly_coeff_t));\n    memcpy(coef_copy, coef_arr1, copy_size * sizeof(poly_coeff_t));\n    coef_copy[90]++;\n\n    {\n        Poly p1 = PolyFromCoeff(1);\n        Poly p2 = PolyFromCoeff(1);\n        Poly p3 = PolyFromCoeff(2);\n        if (!PolyIsEq(&p1, &p2))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 1\");\n            result = false;\n        }\n        if (PolyIsEq(&p1, &p3))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 2\");\n            result = false;\n        }\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n    }\n    if (result)\n    {\n        Poly p1 = MakePoly(100, coef_arr1, exp_arr);\n        Poly p2 = MakePoly(100, coef_arr1, exp_arr);\n        Poly p3 = MakePoly(100, coef_copy, exp_arr);\n        if (!PolyIsEq(&p1, &p2))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 3\");\n            result = false;\n        }\n        if (PolyIsEq(&p1, &p3))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 4\");\n            result = false;\n        }\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n\n    }\n    if (result)\n    {\n        Poly p1 = BuildRecursivePoly(coef_arr1, exp_arr, 100);\n        Poly p2 = BuildRecursivePoly(coef_arr1, exp_arr, 100);\n        Poly p3 = BuildRecursivePoly(coef_copy, exp_arr, 100);\n        if (!PolyIsEq(&p1, &p2))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 5\");\n            result = false;\n        }\n        if (PolyIsEq(&p1, &p3))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 6\");\n            result = false;\n        }\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n\n    }\n    if (result)\n    {\n        int exp_shift_base = 0;\n        int coef_shift_base = 5;\n        int exp_shift = exp_shift_base;\n        int coef_shift = coef_shift_base;\n\n\n        Poly p1 = RecursiveBuild2(3, &exp_shift, &coef_shift, coef_arr1, exp_arr);\n        exp_shift = exp_shift_base;\n        coef_shift = coef_shift_base;\n        Poly p2 = RecursiveBuild2(3, &exp_shift, &coef_shift, coef_arr1, exp_arr);\n        exp_shift = exp_shift_base;\n        coef_shift = coef_shift_base;\n        Poly p3 = RecursiveBuild2(3, &exp_shift, &coef_shift, coef_copy, exp_arr);\n\n        if (!PolyIsEq(&p1, &p2))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 7\");\n            result = false;\n        }\n        if (PolyIsEq(&p1, &p3))\n        {\n            fprintf(stderr, \"[IsEqTest] fail 8\");\n            result = false;\n        }\n        PolyDestroy(&p1);\n        PolyDestroy(&p2);\n        PolyDestroy(&p3);\n    }\n    free(coef_copy);\n\n    return result;\n}\n\n\n/**\n * Sprawdza czy jest używana implementacja wielomianów,\n * która nie zajmuje dużej ilości pamięci dla rzadkich wielomianów.\n * Test będzie uruchamiany z małym limitem pamięci.\n */\nbool RarePolynomialTest()\n{\n    bool result = true;\n    const size_t size = 4000;\n    poly_exp_t rare_exp_arr[size];\n    rare_exp_arr[0] = exp_arr2[0];\n    poly_coeff_t sum = coef_arr1[0];\n    for (size_t i = 1; i < size; ++i)\n    {\n        rare_exp_arr[i] = rare_exp_arr[i-1] + exp_arr2[i];\n        sum += coef_arr1[i];\n    }\n    Poly p = MakePoly(size, coef_arr1, rare_exp_arr);\n    Poly expected_res = PolyFromCoeff(sum);\n    Poly res = PolyAt(&p, 1);\n    if (!PolyIsEq(&expected_res, &res))\n    {\n        fprintf(stderr, \"[RarePolynomialTest] fail 1\");\n        result = false;\n    }\n    if (PolyDeg(&p) != rare_exp_arr[size-1])\n    {\n        fprintf(stderr, \"[RarePolynomialTest] fail 2\");\n        result = false;\n    }\n    PolyDestroy(&p);\n    PolyDestroy(&res);\n    PolyDestroy(&expected_res);\n    return result;\n}\n\n// Sekcja z testami tworzonymi ręcznie\n\n#define C PolyFromCoeff\n\n\nPoly MakePolyHelper(int dummy, ...)\n{\n    va_list list;\n    va_start(list, dummy);\n    unsigned count = 0;\n    while (true)\n    {\n        va_arg(list, Poly);\n        if (va_arg(list, int) < 0)\n            break;\n        count++;\n    }\n    va_start(list, dummy);\n    Mono *arr = calloc(count, sizeof(Mono));\n    for (unsigned i = 0; i < count; ++i)\n    {\n        Poly p = va_arg(list, Poly);\n        arr[i] = MonoFromPoly(&p, va_arg(list, int));\n        assert(i == 0 || arr[i].exp > arr[i - 1].exp);\n    }\n    Poly closing_zero = va_arg(list, Poly);\n    va_end(list);\n    PolyDestroy(&closing_zero);\n    Poly res = PolyAddMonos(count, arr);\n    free(arr);\n    return res;\n}\n\n/**\n * Pomocnicze makro do tworzenia wielomianów.\n * P(@f$ c_0, e_0, c_1, e_1, \\ldots @f$) tworzy wielomian\n * @f$ c_0x^{e_0} + c_1x^{e_1} + \\ldots @f$\n */\n#define P(...) MakePolyHelper(0, __VA_ARGS__, PolyZero(), -1)\n\n/**\n * Testuje czy Stopień wielomianu jest poprawnie liczony rekurencyjnie.\n */\nbool DegTest()\n{\n    Poly p = P(P(C(1), 1, C(1), 10), 1, P(C(1), 1, C(1), 2), 2);\n    if (PolyDeg(&p) != 11)\n    {\n        fprintf(stderr, \"[DegTest] PolyDeg error\\n\");\n        return false;\n    }\n    PolyDestroy(&p);\n    return true;\n}\n\nstatic inline bool TestOpC(Poly a, Poly b, Poly res,\n                           Poly (*op)(const Poly *, const Poly *))\n{\n    Poly c = op(&a, &b);\n    bool is_eq = PolyIsEq(&c, &res);\n    PolyDestroy(&a);\n    PolyDestroy(&b);\n    PolyDestroy(&c);\n    PolyDestroy(&res);\n    return is_eq;\n}\n\nbool TestAdd(Poly a, Poly b, Poly res)\n{\n    return TestOpC(a, b, res, PolyAdd);\n}\n\nbool TestAddMonos(unsigned count, Mono monos[], Poly res)\n{\n    Poly b = PolyAddMonos(count, monos);\n    bool is_eq = PolyIsEq(&b, &res);\n    PolyDestroy(&b);\n    PolyDestroy(&res);\n    return is_eq;\n}\n\nbool TestMul(Poly a, Poly b, Poly res)\n{\n    return TestOpC(a, b, res, PolyMul);\n}\n\nbool TestSub(Poly a, Poly b, Poly res)\n{\n    return TestOpC(a, b, res, PolySub);\n}\n\nbool TestDegBy(Poly a, unsigned var_idx, int res)\n{\n    bool is_eq = PolyDegBy(&a, var_idx) == res;\n    PolyDestroy(&a);\n    return is_eq;\n}\n\nbool TestDeg(Poly a, int res)\n{\n    bool is_eq = PolyDeg(&a) == res;\n    PolyDestroy(&a);\n    return is_eq;\n}\n\nbool TestEq(Poly a, Poly b, bool res)\n{\n    bool is_eq = PolyIsEq(&a, &b) == res;\n    PolyDestroy(&a);\n    PolyDestroy(&b);\n    return is_eq;\n}\n\nbool TestAt(Poly a, poly_coeff_t x, Poly res)\n{\n    Poly b = PolyAt(&a, x);\n    bool is_eq = PolyIsEq(&b, &res);\n    PolyDestroy(&a);\n    PolyDestroy(&b);\n    PolyDestroy(&res);\n    return is_eq;\n}\n\nbool SimpleAddTest()\n{\n    bool res = true;\n    // Różne przypadki wielomian/współczynnik\n    res &= TestAdd(\n            C(1),\n            C(2),\n            C(3));\n    res &= TestAdd(\n            P(C(1), 1),\n            C(2),\n            P(C(2), 0, C(1), 1));\n    res &= TestAdd(\n            C(1),\n            P(C(2), 2),\n            P(C(1), 0, C(2), 2));\n    res &= TestAdd(\n            P(C(1), 1),\n            P(C(2), 2),\n            P(C(1), 1, C(2), 2));\n    res &= TestAdd(\n            C(0),\n            P(C(1), 1),\n            P(C(1), 1));\n    // Upraszczanie się wielomianu\n    res &= TestAdd(\n            P(C(1), 1),\n            P(C(-1), 1),\n            C(0));\n    res &= TestAdd(\n            P(C(1), 1, C(2), 2),\n            P(C(-1), 1),\n            P(C(2), 2));\n    res &= TestAdd(\n            P(C(2), 0, C(1), 1),\n            P(C(-1), 1),\n            C(2));\n    // Dodawanie współczynnika i upraszczanie\n    res &= TestAdd(\n            C(1),\n            P(C(-1), 0, C(1), 1),\n            P(C(1), 1));\n    res &= TestAdd(\n            C(1),\n            P(P(C(-1), 0, C(1), 1), 0),\n            P(P(C(1), 1), 0));\n    res &= TestAdd(\n            C(1),\n            P(C(1), 0, C(2), 2),\n            P(C(2), 0, C(2), 2));\n    res &= TestAdd(\n            C(1),\n            P(P(C(1), 0, C(1), 1), 0, C(2), 2),\n            P(P(C(2), 0, C(1), 1), 0, C(2), 2));\n    res &= TestAdd(\n            C(1),\n            P(P(C(-1), 0, C(1), 1), 0, C(2), 2),\n            P(P(C(1), 1), 0, C(2), 2));\n    // Dodawanie wielomianów wielu zmiennych\n    res &= TestAdd(\n            P(P(C(1), 2), 0, P(C(2), 1), 1, C(1), 2),\n            P(P(C(1), 2), 0, P(C(-2), 1), 1, C(1), 2),\n            P(P(C(2), 2), 0, C(2), 2));\n    res &= TestAdd(\n            P(P(C(1), 2), 0, P(C(2), 1), 1, C(1), 2),\n            P(P(C(-1), 2), 0, P(C(1), 0, C(2), 1, C(1), 2), 1, C(-1), 2),\n            P(P(C(1), 0, C(4), 1, C(1), 2), 1));\n    // Redukcja do współczynnika\n    res &= TestAdd(\n            P(P(C(1), 0, C(1), 1), 0, C(1), 1),\n            P(P(C(1), 0, C(-1), 1), 0, C(-1), 1),\n            C(2));\n    res &= TestAdd(\n            P(P(P(C(1), 0, C(1), 1), 0, C(1), 1), 1),\n            P(P(P(C(1), 0, C(-1), 1), 0, C(-1), 1), 1),\n            P(C(2), 1));\n    // Dodawanie wielomianu do siebie\n    {\n        Poly a = P(C(1), 1);\n        Poly b = PolyAdd(&a, &a);\n        Poly c = P(C(2), 1);\n        res &= PolyIsEq(&b, &c);\n        PolyDestroy(&a);\n        PolyDestroy(&b);\n        PolyDestroy(&c);\n    }\n    return res;\n}\n\nstatic inline Mono M(Poly p, poly_exp_t e)\n{\n    return MonoFromPoly(&p, e);\n}\n\nbool SimpleAddMonosTest()\n{\n    bool res = true;\n    {\n        Mono m[] = { M(C(-1), 0), M(C(1), 0) };\n        res &= TestAddMonos(2, m, C(0));\n    }\n    {\n        Mono m[] = { M(C(-1), 1), M(C(1), 1) };\n        res &= TestAddMonos(2, m, C(0));\n    }\n    {\n        Mono m[] = { M(C(1), 0), M(C(1), 0) };\n        res &= TestAddMonos(2, m, C(2));\n    }\n    {\n        Mono m[] = { M(C(1), 1), M(C(1), 1) };\n        res &= TestAddMonos(2, m, P(C(2), 1));\n    }\n    {\n        Mono m[] = { M(P(C(-1), 1), 0), M(P(C(1), 1), 0) };\n        res &= TestAddMonos(2, m, C(0));\n    }\n    {\n        Mono m[] = { M(P(C(-1), 0), 1), M(P(C(1), 0), 1),\n                     M(C(2), 0), M(C(1), 1),\n                     M(P(C(2), 1), 2), M(P(C(2), 2), 2) };\n        res &= TestAddMonos(6, m, P(C(2), 0, C(1), 1, P(C(2), 1, C(2), 2), 2));\n    }\n    return res;\n}\n\nbool SimpleMulTest()\n{\n    bool res = true;\n    res &= TestMul(\n            C(2),\n            C(3),\n            C(6));\n    res &= TestMul(\n            P(C(1), 1),\n            C(2),\n            P(C(2), 1));\n    res &= TestMul(\n            C(3),\n            P(C(2), 2),\n            P(C(6), 2));\n    res &= TestMul(\n            P(C(1), 1),\n            P(C(2), 2),\n            P(C(2), 3));\n    res &= TestMul(\n            P(C(-1), 0, C(1), 1),\n            P(C(1), 0, C(1), 1),\n            P(C(-1), 0, C(1), 2));\n    res &= TestMul(\n            P(P(C(1), 2), 0, P(C(1), 1), 1, C(1), 2),\n            P(P(C(1), 2), 0, P(C(-1), 1), 1, C(1), 2),\n            P(P(C(1), 4), 0, P(C(1), 2), 2, C(1), 4));\n    return res;\n}\n\nbool SimpleNegTest()\n{\n    Poly a = P(P(C(1), 0, C(2), 2), 0, P(C(1), 1), 1, C(1), 2);\n    Poly b = PolyNeg(&a);\n    Poly c = P(P(C(-1), 0, C(-2), 2), 0, P(C(-1), 1), 1, C(-1), 2);\n    bool is_eq = PolyIsEq(&b, &c);\n    PolyDestroy(&a);\n    PolyDestroy(&b);\n    PolyDestroy(&c);\n    return is_eq;\n}\n\nbool SimpleSubTest()\n{\n    return TestSub(\n            P(P(C(1), 2), 0, P(C(2), 1), 1, C(1), 2),\n            P(P(C(1), 2), 0, P(C(-1), 0, C(-2), 1, C(-1), 2), 1, C(1), 2),\n            P(P(C(1), 0, C(4), 1, C(1), 2), 1));\n}\n\n#define POLY_P P(P(C(1), 3), 0, P(C(1), 2), 2, C(1), 3)\n\nbool SimpleDegByTest()\n{\n    bool res = true;\n    res &= TestDegBy(C(0), 1, -1);\n    res &= TestDegBy(C(1), 0, 0);\n    res &= TestDegBy(P(C(1), 1), 1, 0);\n    res &= TestDegBy(POLY_P, 0, 3);\n    res &= TestDegBy(POLY_P, 1, 3);\n    return res;\n}\n\nbool SimpleDegTest()\n{\n    bool res = true;\n    res &= TestDeg(C(0), -1);\n    res &= TestDeg(C(1), 0);\n    res &= TestDeg(P(C(1), 1), 1);\n    res &= TestDeg(POLY_P, 4);\n    return res;\n}\n\nbool SimpleIsEqTest()\n{\n    bool res = true;\n    res &= TestEq(C(0), C(0), true);\n    res &= TestEq(C(0), C(1), false);\n    res &= TestEq(C(1), C(1), true);\n    res &= TestEq(P(C(1), 1), C(1), false);\n    res &= TestEq(P(C(1), 1), P(C(1), 1), true);\n    res &= TestEq(P(C(1), 1), P(C(1), 2), false);\n    res &= TestEq(P(C(1), 1), P(C(2), 1), false);\n    res &= TestEq(POLY_P, POLY_P, true);\n    {\n        Poly a = C(1);\n        Poly b = C(2);\n        Poly p = POLY_P;\n        res &= TestEq(PolyAdd(&p, &a), PolyAdd(&p, &b), false);\n        PolyDestroy(&a);\n        PolyDestroy(&b);\n        PolyDestroy(&p);\n    }\n    return res;\n}\n\nbool SimpleAtTest()\n{\n    bool res = true;\n    res &= TestAt(C(2), 1, C(2));\n    res &= TestAt(P(C(1), 0, C(1), 18), 10, C(1000000000000000001L));\n    res &= TestAt(P(C(3), 1, C(2), 3, C(1), 5), 10, C(102030));\n    res &= TestAt(P(P(C(1), 4), 0, P(C(1), 2), 2, C(1), 3), 2,\n                  P(C(8), 0, C(4), 2, C(1), 4));\n    return res;\n}\n\nbool OverflowTest()\n{\n    bool res = true;\n    res &= TestMul(P(C(1L << 32), 1), C(1L << 32), C(0));\n    res &= TestAt(P(C(1), 64), 2, C(0));\n    res &= TestAt(P(C(1), 0, C(1), 64), 2, C(1));\n    res &= TestAt(P(P(C(1), 1), 64), 2, C(0));\n    return res;\n}\n\nvoid MemoryTest()\n{\n    Poly *p = malloc(sizeof(struct Poly));\n    *p = PolyFromCoeff(5);\n    Mono m = MonoFromPoly(p, 4);\n    *p = PolyFromCoeff(3);\n    PolyDestroy(p);\n    free(p); // To nie jest Destroy, to tylko zwalnia malloca\n    Poly p2 = PolyAddMonos(1, &m);\n    Poly p3 = PolyAt(&p2, 2);\n    Poly p4 = PolyFromCoeff(80);\n    if (!PolyIsEq(&p4, &p3)){\n        fprintf(stderr, \"[MemoryTest] error\");\n    }\n    PolyDestroy(&p2);\n    PolyDestroy(&p3);\n    PolyDestroy(&p4);\n}\n",
			"malloc",
			"AddTest1",
			"PolyAddMonos",
			"PolyAddMons",
			"malloc",
			"m->",
			"m",
			";\n",
			"TODO",
			"PolyNeg",
			"introduction",
			"SYMMETRIC",
			"introduction",
			"align=\"middle\"",
			"align",
			"introduction",
			"td",
			"pre",
			"introduction",
			"informational",
			"fileName",
			"FileName",
			"fileName",
			"FileName",
			"fileName",
			"exercise 1",
			"nested",
			"exercise 2",
			"trees",
			"hierarchical com",
			"trees in",
			"recursion ex",
			"re",
			"img",
			"p",
			"%\">%</",
			">%<",
			"max-width: 100",
			"style=\"width:100%\"",
			"<p><img",
			"img src",
			"img",
			"<p><img",
			"img",
			"p><img",
			"p><i",
			"img",
			"\"><img",
			"><i",
			"c2",
			"c1",
			"complex r",
			"complex",
			"type: c",
			"ctes with",
			"recursion e",
			"TODO",
			"ctes-com",
			"tag",
			"ctes-co",
			"cook_minutes",
			"in each",
			"minut",
			"cook_minutes",
			"minutes"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Wielomiany1/src/poly.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14513,
						"regions":
						{
						},
						"selection":
						[
							[
								1758,
								1758
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1128.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Wielomiany1/src/poly.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4710,
						"regions":
						{
						},
						"selection":
						[
							[
								913,
								913
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Wielomiany1/src/test_poly.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47810,
						"regions":
						{
						},
						"selection":
						[
							[
								22195,
								22195
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14142.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "Wielomiany1/src/tmp_test.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1205,
						"regions":
						{
						},
						"selection":
						[
							[
								1192,
								1192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 132.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "Wielomiany1/TestKinds.param",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 978,
						"regions":
						{
						},
						"selection":
						[
							[
								6,
								6
							]
						],
						"settings":
						{
							"auto_name": "all                - run all tests",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 100.0
	},
	"pinned_build_system": "",
	"project": "Wielomiany.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
